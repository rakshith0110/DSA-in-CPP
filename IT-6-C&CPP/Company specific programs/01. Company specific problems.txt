01. Problem Description :

The function accepts two positive integers ‘r’ and ‘unit’ and a positive integer array ‘arr’ of size ‘n’ as its argument ‘r’ represents the number of rats present in an area, ‘unit’ is the amount of food each rat consumes and each ith element of array ‘arr’ represents the amount of food present in ‘i+1’ house number, where 0 <= i

Note:

Return -1 if the array is null
Return 0 if the total amount of food from all houses is not sufficient for all the rats.
Computed values lie within the integer range.
Example:

Input:

r: 7
unit: 2
n: 8
arr: 2 8 3 5 7 4 1 2
Output:

4

Explanation:
Total amount of food required for all rats = r * unit

= 7 * 2 = 14.

The amount of food in 1st houses = 2+8+3+5 = 18. Since, amount of food in 1st 4 houses is sufficient for all the rats. Thus, output is 4.



#include <stdio.h>

int calculate (int r, int unit, int arr[], int n)
{
  if (n == 0)
    return -1;
  int totalFoodRequired = r * unit;
  int foodTillNow = 0;
  int house = 0;
  for (house = 0; house < n; ++house)
    {
      foodTillNow += arr[house];
      if (foodTillNow >= totalFoodRequired)
	{
	  break;
	}
    }
  if (totalFoodRequired > foodTillNow)
    return 0;
  return house + 1;
}

int main ()
{
  int r;
  scanf ("%d", &r);
  int unit;
  scanf ("%d", &unit);
  int n;
  scanf ("%d", &n);
  int arr[n];
  for (int i = 0; i < n; ++i)
    {
      scanf ("%d", &arr[i]);
    }
  printf ("%d", calculate (r, unit, arr, n));
  return 0;
}





04. Problem description:
You are given a function,
int findCount(int arr[], int length, int num, int diff);
The function accepts an integer array ‘arr’, its length and two integer variables ‘num’ and ‘diff’. Implement this function to find and return the number of elements of ‘arr’ having an absolute difference of less than or equal to ‘diff’ with ‘num’.
Note: In case there is no element in ‘arr’ whose absolute difference with ‘num’ is less than or equal to ‘diff’, return -1.

Example:

Input:
• arr: 12 3 14 56 77 13
• num: 13
• diff: 2
Output:
3


#include <stdio.h>
#include <stdlib.h>

int findCount (int n, int arr[], int num, int diff)
{
  int count = 0;
  for (int i = 0; i < n; ++i)
    {
      if (abs (arr[i] - num) <= diff)
	{
	  count++;
	}
    }
  return count > 0 ? count : -1;
}

int main ()
{
  int n;
  scanf ("%d", &n);
  int arr[n];
  for (int i = 0; i < n; ++i)
    {
      scanf ("%d", &arr[i]);
    }
  int num;
  scanf ("%d", &num);
  int diff;
  scanf ("%d", &diff);
  printf ("%d\n", findCount (n, arr, num, diff));
  return 0;
}

---------------------------------

02 Problem Description :
The Binary number system only uses two digits, 0 and 1 and number system can be called binary string. You are required to implement the following function:

int OperationsBinaryString(char* str);

The function accepts a string str as its argument. The string str consists of binary digits eparated with an alphabet as follows:

– A denotes AND operation
– B denotes OR operation
– C denotes XOR Operation
You are required to calculate the result of the string str, scanning the string to right taking one operation at a time, and return the same.

Note:

No order of priorities of operations is required
Length of str is odd
If str is NULL or None (in case of Python), return -1
Input:
str: 1C0C1C1A0B1

Output:
1

Explanation:
The alphabets in str when expanded becomes “1 XOR 0 XOR 1 XOR 1 AND 0 OR 1”, result of the expression becomes 1, hence 1 is returned.

Sample Input:
0C1A1B1C1C1B0A0

Output:
0

Solution:

#include <stdio.h>
#include <string.h>  

int OperationsBinaryString (char *str)
{
  if (str == NULL)
    return -1;
  int i = 1;
  int a = *str - '0';
  str++;
  while (*str != '\0')
    {
      char p = *str;
      str++;
      if (p == 'A')
	a &= (*str - '0');
      else if (p == 'B')
	a |= (*str - '0');
      else
	a ^= (*str - '0');
      str++;
    }
  return a;
}

int main ()
{
  char str[100];
  fgets (str, sizeof (str), stdin);
  int len = strlen (str);
  if (str[len - 1] == '\n')
    {
      str[len - 1] = '\0';	// Remove the newline character
      len--;			// Decrement the length
    }
  int result = OperationsBinaryString (str);
  printf ("%d\n", result);
  return 0;
}


----------------------------------
03 Problem description:

You are given a function.
int CheckPassword(char str[], int n);
The function accepts string str of size n as an argument. Implement the function which returns 1 if given string str is valid password else 0.
str is a valid password if it satisfies the below conditions.

– At least 4 characters
– At least one numeric digit
– At Least one Capital Letter
– Must not have space or slash (/)
– Starting character must not be a number
Assumption:
Input string will not be empty.

Example:

Input 1:
aA1_67
Input 2:
a987 abC012

Output 1:
1
Output 2:
0



Solution:

#include <stdio.h>
#include <string.h>

int CheckPassword (char str[], int n)
{
  // At least 4 characters
  if (n < 4)
    return 0;
  // Starting character must not be a number
  if (str[0] - '0' >= 0 && str[0] - '0' <= 9)
    return 0;
  int a = 0, cap = 0, nu = 0;
  while (a < n)
    {
      // Must not have space or slash (/)
      if (str[a] == ' ' || str[a] == '/')
	return 0;
      // Counting capital letters
      if (str[a] >= 'A' && str[a] <= 'Z')
	{
	  cap++;
	}
      // Counting numeric digits
      else if (str[a] - '0' >= 0 && str[a] - '0' <= 9)
	{
	  nu++;
	}
      // Incrementing for the while loop
      a++;
    }
  // Returns 1 if there are > 0 numeric digits and capital letters
  return cap > 0 && nu > 0;
}

int main ()
{
  char str[100];
  fgets (str, sizeof (str), stdin);
  int len = strlen (str);
  if (str[len - 1] == '\n')
    {
      str[len - 1] = '\0';	// Remove the newline character
      len--;			// Decrement the length
    }
  int result = CheckPassword (str, len);
  printf ("%d\n", result);
  return 0;
}



Explanation

Second largest among even position elements(1 3 5) is 3
Second smallest among odd position element is 4
Thus output is 3+4 = 7
Sample Input

arr:1 8 0 2 3 5 6

Sample Output

8

#include <stdio.h>

int LargeSmallSum (int arr[], int length)
{
  if (length <= 3)
    {
      return 0;
    }

  int evenPos[100], oddPos[100];
  int evenCount = 0, oddCount = 0;

  for (int i = 0; i < length; i++)
    {
      if (i % 2 == 0)
	{
	  evenPos[evenCount++] = arr[i];
	}
      else
	{
	  oddPos[oddCount++] = arr[i];
	}
    }

  // Sort the even position array in descending order
  for (int i = 0; i < evenCount - 1; i++)
    {
      for (int j = 0; j < evenCount - i - 1; j++)
	{
	  if (evenPos[j] < evenPos[j + 1])
	    {
	      int temp = evenPos[j];
	      evenPos[j] = evenPos[j + 1];
	      evenPos[j + 1] = temp;
	    }
	}
    }

  // Sort the odd position array in ascending order
  for (int i = 0; i < oddCount - 1; i++)
    {
      for (int j = 0; j < oddCount - i - 1; j++)
	{
	  if (oddPos[j] > oddPos[j + 1])
	    {
	      int temp = oddPos[j];
	      oddPos[j] = oddPos[j + 1];
	      oddPos[j + 1] = temp;
	    }
	}
    }

  return evenPos[1] + oddPos[1];
}

int main ()
{
  int arr[] = { 3, 2, 1, 7, 5, 4 };
  int length = sizeof (arr) / sizeof (arr[0]);

  int result = LargeSmallSum (arr, length);
  printf ("%d\n", result);

  return 0;
}


------------------------------

07 Problem description

Implement the following Function

def ProductSmallestPair(sum, arr)

The function accepts an integers sum and an integer array arr of size n. Implement the function to find the pair, (arr[j], arr[k]) where j!=k, Such that arr[j] and arr[k] are the least two elements of array (arr[j] + arr[k] <= sum) and return the product of element of this pair

NOTE

Return -1 if array is empty or if n<2
Return 0, if no such pairs found
All computed values lie within integer range
Example

Input

sum:9

size of Arr = 7

Arr:5 2 4 3 9 7 1

Output

2

Explanation

Pair of least two element is (2, 1) 2 + 1 = 3 < 9, Product of (2, 1) 2*1 = 2. Thus, output is 2

Sample Input

sum:4

size of Arr = 6

Arr:9 8 3 -7 3 9

Sample Output

-21

Solution:

#include<stdio.h>
int productSmallestPair (int *array, int n, int sum)
{
  int answer, temp, i, j, check;
  if (n < 2)
    {
      answer = -1;
    }
  else
    {
      for (i = 0; i < n; i++)	//sorting of array
	{
	  for (j = i + 1; j < n; j++)
	    {
	      if (array[i] > array[j])
		{
		  temp = array[i];
		  array[i] = array[j];
		  array[j] = temp;
		}
	    }
	}
      check = array[0] + array[1];
      if (check <= sum)
	{
	  answer = array[0] * array[1];
	}
      else
	{
	  answer = 0;
	}
    }
  return answer;
}
int main ()
{
  int n, sum, result, i;
  scanf ("%d", &sum);
  scanf ("%d", &n);
  int array[n];
  for (i = 0; i < n; i++)
    {
      scanf ("%d", &array[i]);
    }
  result = productSmallestPair (array, n, sum);
  printf ("%d", result);
  return 0;
}


