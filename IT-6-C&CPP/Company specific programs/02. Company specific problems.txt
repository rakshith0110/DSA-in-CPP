
06 Problem description
You are required to implement the following Function 

def LargeSmallSum(arr)

The function accepts an integers arr of size ’length’ as its arguments you are required to return the sum of second largest  element from the even positions and second smallest from the odd position of given ‘arr’

Assumption:

All array elements are unique
Treat the 0th position as even
NOTE

Return 0 if array is empty
Return 0, if array length is 3 or less than 3
Example

Input

arr:3 2 1 7 5 4

Output

7

Explanation

Second largest among even position elements(1 3 5) is 3
Second smallest among odd position element is 4
Thus output is 3+4 = 7
Sample Input

arr:1 8 0 2 3 5 6

Sample Output

8

#include <stdio.h>

int LargeSmallSum (int arr[], int length)
{
  if (length <= 3)
    {
      return 0;
    }

  int evenPos[100], oddPos[100];
  int evenCount = 0, oddCount = 0;

  for (int i = 0; i < length; i++)
    {
      if (i % 2 == 0)
	{
	  evenPos[evenCount++] = arr[i];
	}
      else
	{
	  oddPos[oddCount++] = arr[i];
	}
    }

  // Sort the even position array in descending order
  for (int i = 0; i < evenCount - 1; i++)
    {
      for (int j = 0; j < evenCount - i - 1; j++)
	{
	  if (evenPos[j] < evenPos[j + 1])
	    {
	      int temp = evenPos[j];
	      evenPos[j] = evenPos[j + 1];
	      evenPos[j + 1] = temp;
	    }
	}
    }

  // Sort the odd position array in ascending order
  for (int i = 0; i < oddCount - 1; i++)
    {
      for (int j = 0; j < oddCount - i - 1; j++)
	{
	  if (oddPos[j] > oddPos[j + 1])
	    {
	      int temp = oddPos[j];
	      oddPos[j] = oddPos[j + 1];
	      oddPos[j + 1] = temp;
	    }
	}
    }

  return evenPos[1] + oddPos[1];
}

int main ()
{
  int arr[] = { 3, 2, 1, 7, 5, 4 };
  int length = sizeof (arr) / sizeof (arr[0]);

  int result = LargeSmallSum (arr, length);
  printf ("%d\n", result);

  return 0;
}


------------------------------

07 Problem description

Implement the following Function

def ProductSmallestPair(sum, arr)

The function accepts an integers sum and an integer array arr of size n. Implement the function to find the pair, (arr[j], arr[k]) where j!=k, Such that arr[j] and arr[k] are the least two elements of array (arr[j] + arr[k] <= sum) and return the product of element of this pair

NOTE

Return -1 if array is empty or if n<2
Return 0, if no such pairs found
All computed values lie within integer range
Example

Input
sum:9
size of Arr = 7
Arr:5 2 4 3 9 7 1

Output
2

Explanation

Pair of least two element is (2, 1) 2 + 1 = 3 < 9, Product of (2, 1) 2*1 = 2. Thus, output is 2

Sample Input

sum:4
size of Arr = 6
Arr:9 8 3 -7 3 9

Sample Output
-21

Solution:

#include<stdio.h>
int productSmallestPair (int *array, int n, int sum)
{
  int answer, temp, i, j, check;
  if (n < 2)
    {
      answer = -1;
    }
  else
    {
      for (i = 0; i < n; i++)	//sorting of array
	{
	  for (j = i + 1; j < n; j++)
	    {
	      if (array[i] > array[j])
		{
		  temp = array[i];
		  array[i] = array[j];
		  array[j] = temp;
		}
	    }
	}
      check = array[0] + array[1];
      if (check <= sum)
	{
	  answer = array[0] * array[1];
	}
      else
	{
	  answer = 0;
	}
    }
  return answer;
}
int main ()
{
  int n, sum, result, i;
  scanf ("%d", &sum);
  scanf ("%d", &n);
  int array[n];
  for (i = 0; i < n; i++)
    {
      scanf ("%d", &array[i]);
    }
  result = productSmallestPair (array, n, sum);
  printf ("%d", result);
  return 0;
}


-----------------------

Problem 8:

N-base notation is a system for writing numbers that uses only n different symbols, This symbols are the first n symbols from the given notation list(Including the symbol for o) Decimal to n base notation are (0:0, 1:1, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:9, 10:A,11:B and so on upto 35:Z)

Implement the following function

Char* DectoNBase(int n, int num):

The function accept positive integer n and num Implement the function to calculate the n-base equivalent of num and return the same as a string

Steps:

Divide the decimal number by n,Treat the division as the integer division
Write the the remainder (in  n-base notation)
Divide the quotient again by n, Treat the division as integer division
Repeat step 2 and 3 until the quotient is 0
The n-base value is the sequence of the remainders from last to first
Assumption:
1 < n < = 36

Example

Input
n: 12
num: 718

Output
4BA

Explanation
num       Divisor       quotient       remainder
718           12               59          10(A)
59            12                4          11(B)
4             12                0          4(4)

Sample Input
n: 21
num: 5678

Sample Output
CI8


#include <stdio.h>

char *decitoNBase (int n, int num)
{
  char *res = NULL;
  int quotient = num / n;
  int *rem = malloc (sizeof (int));
  int remSize = 1;
  rem[0] = num % n;

  while (quotient != 0)
    {
      remSize++;
      int *temp = realloc (rem, remSize * sizeof (int));
      if (temp == NULL)
	{
	  free (rem);
	  return NULL;
	}
      rem = temp;
      rem[remSize - 1] = quotient % n;
      quotient = quotient / n;
    }

  int resSize = remSize + 1;
  res = malloc (resSize * sizeof (char));
  if (res == NULL)
    {
      free (rem);
      return NULL;
    }

  int i, j = 0;
  for (i = remSize - 1; i >= 0; i--)
    {
      if (rem[i] > 9)
	{
	  res[j] = (char) (rem[i] - 9 + 64);
	}
      else
	{
	  res[j] = (char) (rem[i] + '0');
	}
      j++;
    }
  res[j] = '\0';

  free (rem);
  return res;
}

int main ()
{
  int n, num;
  scanf ("%d %d", &n, &num);
  char *result = decitoNBase (n, num);
  printf ("%s\n", result);
  free (result);
  return 0;
}


-----------------------------------------
09. Problem statement

Implement the following functions.a

char*MoveHyphen(char str[],int n);

The function accepts a string “str” of length ‘n’, that contains alphabets and hyphens (-). Implement the function to move all hyphens(-) in the string to the front of the given string.

NOTE:- Return null if str is null.

Example :-

Input:
str.Move-Hyphens-to-Front
Output:
—MoveHyphenstoFront
Explanation:-

The string “Move-Hyphens -to-front” has 3 hyphens (-), which are moved to the front of the string, this output is “— MoveHyphen”

Sample Input

Str: String-Compare
Sample Output-

-StringCompare

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char * MoveHyphen (char *s, int n)
{
  int count = 0;
  int i = 0;
  while (i < n)
    {
      if (s[i] == '-')
	{
	  count++;
	  memmove (&s[i], &s[i + 1], n - i);
	  n--;
	}
      else
	{
	  i++;
	}
    }

  char *res = malloc ((n + count + 1) * sizeof (char));
  if (res == NULL)
    {
      return NULL;
    }

  for (i = 0; i < count; i++)
    {
      res[i] = '-';
    }
  for (i = count; i < count + n; i++)
    {
      res[i] = s[i - count];
    }
  res[count + n] = '\0';

  return res;
}

int main ()
{
  char s[100];
  scanf ("%s", s);
  int n = strlen (s);
  char *result = MoveHyphen (s, n);
  printf ("%s\n", result);
  free (result);
  return 0;
}

------------------------------------
